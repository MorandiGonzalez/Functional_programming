(defun input-poly (p &aux x res i f sign coef u)
  (setq coef 0)
  (setq sign 1)
  (setq u    0)
  (setq f    0)
  (setq x (explode p))
  (dolist (i x res) 
    (cond ((EQ i '+) (progn (when (and (= u 0) (= f 1)) (setq u 1))
                           (if (> f 0) (setq res (append res (list (list coef u))))
                                       (setq res (append res (list (list u 0)))))  
                           (setq sign 1)
                           (setq u 0)
                           (setq f 0)
                           (setq coef 0)))
          ((EQ i '-) (progn (when (and (= u 0) (= f 1)) (setq u 1))
                           (if (> f 0) (setq res (append res (list (list coef u))))
                                       (setq res (append res (list (list u 0)))))  
                           (setq sign -1)
                           (setq u 0)
                           (setq f 0)
                           (setq coef 0)))
          ((fixedp i) (setq u (+ i (* u 10))))
          ((EQ i 'x)   (progn  (when (= u 0) (setq u 1))
                              (setq f 1)
                              (setq coef (* sign u))  
                              (setq u 0)))
          ((EQ i '^) (setq f 2))))
  (cond ((= f 0) (setq res (append res (list (list (* sign u) 0)))))
        (t       (setq res (append res (list (list coef f)))))) 
  (qsort-b (remove '(0 0) res) #'(lambda (x y) (> (cadr x) (cadr y)))))
 
;; --------------------------------------------------------------------------
 
(defun output-poly (x &aux i c p res)
   (dolist (i x (implode res))
      (setq c (car i))
      (setq p (cadr i))
      (when (and (> c 0) (not (null res))) (setq res (append res (list '+))))
      (when (< c 0) (setq res (append res (list '-))) (setq c (abs c)))
      (when (and (= c 1) (null res)) (setq res (append res (list 1))))
      (when (<> c 1) (setq res (append res (list c))))
      (cond ((> p 1) (setq res (append res (list 'x '^ p))))
            ((= p 1) (setq res (append res (list 'x)))))))
 
;; --------------------------------------------------------------------------
 
(defun reduce-poly (x &aux i c p cc cp res lstp)
  (dolist (i x (qsort-b res #'(lambda (x y) (> (cadr x) (cadr y)))))
      (setq cc 0)
      (setq p (cadr i))
      (dolist (j x t) 
         (setq cp (cadr j))
         (when (= cp p) (setq cc (+ cc (car j)))))
      (when (and (<> cc 0) (not (memb p lstp)))
       (setq res (append res (list (list cc p))))
       (setq lstp (cons p lstp)))))
 
;; --------------------------------------------------------------------------
 
(defun diff-poly (p)
   (reduce-poly (mapcar #'(lambda (x) (list (* (car x) (cadr x)) (- (cadr x) 1))) p)))           
 
;; --------------------------------------------------------------------------
  
(defun mult-poly (p1 p2 &aux r)
  (iter (for m1 in p1)
    (iter (for m2 in p2)
      (collecting (list (* (car m1) (car m2)) (+ (cadr m1) (cadr m2))) into r)))
  (reduce-poly r))

(defun poly-gcd (p1 p2)
  (cond ((> (length p2) (length p1)) (poly-gcd p2 p1))
        ((equal p2 (list 0)) p1)
        (t (poly-gcd p2 (cadr (poly-div p1 p2))))))